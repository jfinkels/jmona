/**
 * EdgeRecombinationCrossoverFunction.java
 * 
 * Copyright 2009 Jeffrey Finkelstein
 * 
 * This file is part of jmona.
 * 
 * jmona is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * jmona is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * jmona. If not, see <http://www.gnu.org/licenses/>.
 */
package jmona.example.tsp.crossover;

import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import jmona.CrossoverException;
import jmona.CrossoverFunction;
import jmona.MappingException;
import jmona.functional.Functional;
import jmona.functional.Range;
import jmona.impl.Util;

/**
 * Edge recombination crossover (also known as ERX) for tours in the traveling
 * salesman problem.
 * 
 * @author Jeffrey Finkelstein
 */
public class EdgeRecombinationCrossoverFunction implements
    CrossoverFunction<List<Integer>> {

  /**
   * Remove the specified city from the specified set of neighbors for each
   * city.
   * 
   * @param city
   *          The city to remove.
   * @param neighborSets
   *          The adjacency list as a mapping from city to a set of its neighbor
   *          cities.
   */
  protected static void removeFromAllNeighborSets(final int city,
      final Map<Integer, Set<Integer>> neighborSets) {

    // iterate over each set of neighbors
    for (final Set<Integer> neighbors : neighborSets.values()) {

      // remove the specified city from that set
      neighbors.remove(city);
    }
  }

  /**
   * Gets the single List returned by the edge recombination operator. Edge
   * recombination crossover works as follows.
   * 
   * The edge recombination operator works as follows. First, an adjacency list
   * is created, which maps each city to all of its neighbors in <em>either</em>
   * tour. Second, a new tour is created by repeatedly choosing the city with
   * the fewest neighbors as determined by the size of its adjacency list.
   * 
   * @param tour1
   *          A tour.
   * @param tour2
   *          Another tour.
   * @return The new tour generated by the edge recombination operator
   *         algorithm.
   * @throws CrossoverException
   *           If there is a problem determining which cities satisfy the
   *           condition of having a specific number of neighbors.
   */
  protected List<Integer> edgeRecombinationOperator(final List<Integer> tour1,
      final List<Integer> tour2) throws CrossoverException {

    // initialize the adjacency lists for cities in the tours
    final Map<Integer, Set<Integer>> neighborsBothTours = new HashMap<Integer, Set<Integer>>();

    // get the size of the tours
    final int tourSize = tour1.size();

    // iterate over each city in tour 1
    Set<Integer> neighbors = null;
    for (final int i : new Range(tourSize)) {

      // instantiate a new set of neighbor cities
      neighbors = new HashSet<Integer>();

      // add the neighbors of the current city in both tours
      // note: have to do (i + size - 1), because % operator does not work for
      // negative integers for some reason
      neighbors.add(tour1.get((i + tourSize - 1) % tourSize));
      neighbors.add(tour1.get((i + 1) % tourSize));
      neighbors.add(tour2.get((i + tourSize - 1) % tourSize));
      neighbors.add(tour2.get((i + 1) % tourSize));

      // add this set to the adjacency list for both tours
      neighborsBothTours.put(i, neighbors);
    }

    // choose an initial city to add from a random parent
    int cityToAdd = 0;
    if (Util.RANDOM.nextBoolean()) {
      cityToAdd = tour1.get(0);
    } else {
      cityToAdd = tour2.get(0);
    }

    // create a list of all possible cities to add to the new tour
    final Set<Integer> allPossibleCities = new HashSet<Integer>();
    for (final int i : new Range(tourSize)) {
      allPossibleCities.add(i);
    }

    // create the comparator which counts the number of neighbors of each city
    final Comparator<Integer> neighborCountingComparator = new NeighborCountingComparator(
        neighborsBothTours);

    // create the condition which determines which cities have the same number
    // of neighbors
    final SameNumberOfNeighborsCondition sameNumberOfNeighbors = new SameNumberOfNeighborsCondition(
        neighborsBothTours);

    // create a new tour to contain the recombined individual
    final List<Integer> newTour = new Vector<Integer>();

    // while the new tour is not complete
    int cityWithMinNeighbors = 0;
    int numberOfNeighbors = 0;
    List<Integer> citiesWithSameNumberOfNeighbors = null;
    while (newTour.size() < tourSize) {

      // get the neighbors of the city just added to the tour
      neighbors = neighborsBothTours.get(cityToAdd);

      // if the set of neighbors is empty
      if (neighbors.size() == 0) {

        // choose a random city not already in the new tour
        cityToAdd = Util.randomFromCollection(allPossibleCities);

      } else {

        // get the city with the minimum number of neighbors
        cityWithMinNeighbors = Collections.min(neighborsBothTours
            .get(cityToAdd), neighborCountingComparator);

        // get the number of neighbors of that city
        numberOfNeighbors = neighborsBothTours.get(cityWithMinNeighbors).size();

        // set the condition with the number of neighbors to match
        sameNumberOfNeighbors.setNumberOfNeighborsToMatch(numberOfNeighbors);

        // get all cities with the same number of neighbors
        try {
          citiesWithSameNumberOfNeighbors = Functional.filter(
              sameNumberOfNeighbors, allPossibleCities);
        } catch (final MappingException exception) {
          throw new CrossoverException(
              "Failed to filter cities by number of neighbors.", exception);
        }

        // choose a random city from that list
        cityToAdd = Util.randomFromCollection(citiesWithSameNumberOfNeighbors);

      }

      // add the chosen city to the new tour
      newTour.add(cityToAdd);

      // remove the city just added from the list of all possible cities
      allPossibleCities.remove(cityToAdd);

      // remove that city from the adjacency list
      removeFromAllNeighborSets(cityToAdd, neighborsBothTours);
    }

    return newTour;
  }

  /**
   * Perform edge recombination crossover (also known as ERX) on the two
   * specified tours.
   * 
   * This method calls the {@link #edgeRecombinationOperator(List, List)} method
   * twice to get two similar (but not necessarily exactly the same due to
   * randomness) tours using the edge recombination operator algorithm.
   * 
   * @param tour1
   *          A tour.
   * @param tour2
   *          Another tour.
   * @throws CrossoverException
   *           If there is a problem determining which cities satisfy the
   *           condition of having a specific number of neighbors.
   * @see jmona.CrossoverFunction#crossover(Object, Object)
   */
  @Override
  public void crossover(final List<Integer> tour1, final List<Integer> tour2)
      throws CrossoverException {
    Collections.copy(tour1, this.edgeRecombinationOperator(tour1, tour2));
    Collections.copy(tour2, this.edgeRecombinationOperator(tour1, tour2));
  }

}
